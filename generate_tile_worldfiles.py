#!/usr/bin/env python3
"""
Generate .tfw world files for tiled TIFF files to preserve georeferencing information.

This script creates world files for tiles generated by the GeoTiffTiler class,
allowing tiles to be correctly projected on maps without waiting for full inference.

Usage:
    python generate_tile_worldfiles.py --input /path/to/original.tif --tiles_dir /path/to/tiles --tile_size 128 --overlap 0
"""

import os
import argparse
import rasterio
import rasterio.transform
import math
from pathlib import Path
from typing import Tuple, Optional


def calculate_tile_worldfile_params(
    original_transform: rasterio.transform.Affine,
    tile_size: int,
    row: int,
    col: int,
    step_size: int
) -> Tuple[float, float, float, float, float, float]:
    """
    Calculate world file parameters for a specific tile.
    
    Args:
        original_transform: Affine transform of the original image
        tile_size: Size of the tile in pixels
        row: Tile row index
        col: Tile column index  
        step_size: Step size between tiles (tile_size - overlap)
        
    Returns:
        Tuple of (pixel_size_x, rotation_y, rotation_x, pixel_size_y, x_center, y_center)
    """
    # Calculate tile's pixel position in original image
    x_start = col * step_size
    y_start = row * step_size
    
    # Calculate tile's geographic bounds
    left, top = original_transform * (x_start, y_start)
    right, bottom = original_transform * (x_start + tile_size, y_start + tile_size)
    
    # Calculate tile transform
    tile_transform = rasterio.transform.from_bounds(
        left, bottom, right, top,  # west, south, east, north
        tile_size, tile_size
    )
    
    # Extract world file parameters from tile transform
    # Affine transform: [a, b, c, d, e, f] where:
    # a = pixel width (x-scale)
    # b = row rotation (typically 0)
    # c = x-coordinate of upper-left pixel center
    # d = column rotation (typically 0) 
    # e = pixel height (y-scale, negative)
    # f = y-coordinate of upper-left pixel center
    
    pixel_size_x = tile_transform.a  # x-pixel size (west-east)
    rotation_y = tile_transform.b    # rotation about y-axis
    rotation_x = tile_transform.d    # rotation about x-axis
    pixel_size_y = tile_transform.e  # y-pixel size (north-south, negative)
    x_center = tile_transform.c      # x-coordinate of upper-left pixel center
    y_center = tile_transform.f      # y-coordinate of upper-left pixel center
    
    return pixel_size_x, rotation_y, rotation_x, pixel_size_y, x_center, y_center


def write_world_file(output_path: str, params: Tuple[float, float, float, float, float, float]) -> None:
    """
    Write a world file (.tfw) with the given parameters.
    
    Args:
        output_path: Path to output world file
        params: Tuple of world file parameters
    """
    pixel_size_x, rotation_y, rotation_x, pixel_size_y, x_center, y_center = params
    
    with open(output_path, 'w') as f:
        f.write(f"{pixel_size_x:.10f}\n")     # x-pixel size
        f.write(f"{rotation_y:.10f}\n")      # rotation about y-axis
        f.write(f"{rotation_x:.10f}\n")      # rotation about x-axis  
        f.write(f"{pixel_size_y:.10f}\n")    # y-pixel size (negative)
        f.write(f"{x_center:.10f}\n")        # x-coordinate of center
        f.write(f"{y_center:.10f}\n")        # y-coordinate of center


def parse_tile_filename(filename: str, prefix: str = "tile") -> Optional[Tuple[int, int]]:
    """
    Parse tile filename to extract row and column indices.
    
    Args:
        filename: Tile filename (e.g., "tile_0001_0002.tif" or "dem_tile_0001_0002.tif")
        prefix: Expected prefix (default: "tile")
        
    Returns:
        Tuple of (row, col) or None if parsing fails
    """
    try:
        # Remove extension
        name_without_ext = Path(filename).stem
        
        # Expected format: {prefix}_{row:04d}_{col:04d}
        prefix_with_underscore = f"{prefix}_"
        if not name_without_ext.startswith(prefix_with_underscore):
            return None
        
        # Remove the prefix and underscore to get just the row_col part
        remainder = name_without_ext[len(prefix_with_underscore):]
        
        # Split the remainder by underscore to get row and column
        parts = remainder.split('_')
        if len(parts) != 2:
            return None
            
        row = int(parts[0])
        col = int(parts[1])
        return row, col
        
    except (ValueError, IndexError):
        return None


def generate_worldfiles_for_tiles(
    input_image_path: str,
    tiles_directory: str,
    tile_size: int = 128,
    overlap: int = 0,
    prefix: str = "tile",
    force_overwrite: bool = False
) -> None:
    """
    Generate world files for all tiles in a directory.
    
    Args:
        input_image_path: Path to original georeferenced image
        tiles_directory: Directory containing tile files
        tile_size: Size of tiles in pixels
        overlap: Overlap between tiles in pixels
        prefix: Tile filename prefix
        force_overwrite: Whether to overwrite existing world files
    """
    # Read original image georeference information
    try:
        with rasterio.open(input_image_path) as src:
            original_transform = src.transform
            crs = src.crs
            width = src.width
            height = src.height
    except Exception as e:
        raise ValueError(f"Could not read input image {input_image_path}: {e}")
    
    print(f"Original image: {width}x{height} pixels")
    print(f"CRS: {crs}")
    print(f"Transform: {original_transform}")
    
    # Calculate step size
    step_size = tile_size - overlap
    
    # Calculate expected number of tiles
    tiles_x = math.ceil((width - overlap) / step_size)
    tiles_y = math.ceil((height - overlap) / step_size)
    
    print(f"Expected tiles: {tiles_x}x{tiles_y} = {tiles_x * tiles_y}")
    print(f"Tile size: {tile_size}x{tile_size}")
    print(f"Overlap: {overlap} pixels")
    print(f"Step size: {step_size} pixels")
    
    # Find all tile files
    tiles_dir = Path(tiles_directory)
    if not tiles_dir.exists():
        raise ValueError(f"Tiles directory does not exist: {tiles_directory}")
    
    tile_files = list(tiles_dir.glob(f"{prefix}_*.tif"))
    print(f"Found {len(tile_files)} tile files")
    
    generated_count = 0
    skipped_count = 0
    
    # Process each tile file
    for tile_file in sorted(tile_files):
        # Parse filename to get row and column
        coords = parse_tile_filename(tile_file.name, prefix)
        if coords is None:
            print(f"Warning: Could not parse filename {tile_file.name}, skipping")
            continue
            
        row, col = coords
        
        # Generate world file path
        world_file_path = tile_file.with_suffix('.tfw')
        
        # Check if world file already exists
        if world_file_path.exists() and not force_overwrite:
            print(f"Skipping {tile_file.name} (world file exists)")
            skipped_count += 1
            continue
        
        # Calculate world file parameters
        try:
            params = calculate_tile_worldfile_params(
                original_transform, tile_size, row, col, step_size
            )
            
            # Write world file
            write_world_file(str(world_file_path), params)
            generated_count += 1
            
            if generated_count % 50 == 0:
                print(f"Generated {generated_count} world files...")
                
        except Exception as e:
            print(f"Error processing {tile_file.name}: {e}")
    
    print(f"\nCompleted!")
    print(f"Generated: {generated_count} world files")
    print(f"Skipped: {skipped_count} existing files")
    print(f"Total tiles processed: {len(tile_files)}")


def print_usage_examples():
    """Print detailed usage examples and explanation."""
    print("""
=== TILE WORLD FILE GENERATOR ===

This script generates .tfw world files for tiled TIFF files to preserve georeferencing
information, allowing tiles to be correctly projected on maps without waiting for the
entire inference process to complete.

BASIC USAGE:
    python generate_tile_worldfiles.py --input ORIGINAL_IMAGE --tiles_dir TILES_DIRECTORY

EXAMPLE (based on DEM inpainting workflow):
    python generate_tile_worldfiles.py \\
        --input ./test/21-small.tif \\
        --tiles_dir ./experiments/test_DEM_inpainting_251030_171159/results/test/0/ \\
        --overlap 64 \\
        --prefix dem_tile \\
        --force

PARAMETERS:
    --input, -i      Path to original georeferenced image (e.g., ./test/21-small.tif)
    --tiles_dir, -t  Directory containing tile files (e.g., ./experiments/.../results/test/0/)
    --tile_size, -s  Size of tiles in pixels (default: 128)
    --overlap, -o    Overlap between tiles in pixels (default: 0)
    --prefix, -p     Tile filename prefix (default: "tile", use "dem_tile" for DEM inpainting)
    --force, -f      Overwrite existing world files

WHAT IT DOES:
    1. Reads georeferencing information from the original image
    2. Finds all tile files matching the pattern: {prefix}_XXXX_YYYY.tif
    3. Calculates each tile's geographic position based on its row/column in the grid
    4. Creates .tfw world files with 6 parameters for proper map projection

EXPECTED OUTPUT:
    - One .tfw file for each .tif tile file
    - Files like: dem_tile_0000_0000.tfw, dem_tile_0001_0002.tfw, etc.
    - Each .tfw file contains 6 lines with georeferencing parameters

VERIFICATION:
    Check that .tfw files were created:
        ls your_tiles_directory/*.tfw | wc -l
    
    View a world file:
        cat your_tiles_directory/dem_tile_0000_0000.tfw

INTEGRATION WITH DEM INPAINTING:
    Run this script after tiling but before or during inference to enable immediate
    visualization of tiles in GIS software like QGIS or ArcGIS.

For more help: python generate_tile_worldfiles.py --help
""")

def main():
    parser = argparse.ArgumentParser(
        description="Generate .tfw world files for tiled TIFF files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="Use --help-examples for detailed usage examples"
    )
    parser.add_argument(
        '--help-examples',
        action='store_true',
        help="Show detailed usage examples and explanation"
    )
    parser.add_argument(
        '--input', '-i',
        help="Path to original georeferenced image"
    )
    parser.add_argument(
        '--tiles_dir', '-t',
        help="Directory containing tile files"
    )
    parser.add_argument(
        '--tile_size', '-s',
        type=int,
        default=128,
        help="Size of tiles in pixels (default: 128)"
    )
    parser.add_argument(
        '--overlap', '-o',
        type=int,
        default=0,
        help="Overlap between tiles in pixels (default: 0)"
    )
    parser.add_argument(
        '--prefix', '-p',
        default="tile",
        help="Tile filename prefix (default: 'tile')"
    )
    parser.add_argument(
        '--force', '-f',
        action='store_true',
        help="Overwrite existing world files"
    )
    args = parser.parse_args()
    
    # Show examples if requested
    if args.help_examples:
        print_usage_examples()
        return 0
    
    # Check for required arguments
    if not args.input or not args.tiles_dir:
        print("Error: Both --input and --tiles_dir are required")
        print("Use --help-examples for detailed usage examples")
        return 1
    
    try:
        generate_worldfiles_for_tiles(
            input_image_path=args.input,
            tiles_directory=args.tiles_dir,
            tile_size=args.tile_size,
            overlap=args.overlap,
            prefix=args.prefix,
            force_overwrite=args.force
        )
    except Exception as e:
        print(f"Error: {e}")
        return 1
    
    return 0


if __name__ == "__main__":
    exit(main())